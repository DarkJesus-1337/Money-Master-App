<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/core/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/core/di/AppModule.kt" />
              <option name="updatedContent" value="package com.pixelpioneer.moneymaster.core.di&#10;&#10;import com.pixelpioneer.moneymaster.core.initialization.AppInitializer&#10;import com.pixelpioneer.moneymaster.core.initialization.CategoryInitializer&#10;import com.pixelpioneer.moneymaster.data.repository.CategoryRepository&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import dagger.multibindings.IntoSet&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @IntoSet&#10;    @Singleton&#10;    fun provideCategoryInitializer(categoryRepository: CategoryRepository): AppInitializer {&#10;        return CategoryInitializer(categoryRepository)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/ReceiptScanViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/ReceiptScanViewModel.kt" />
              <option name="originalContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.pixelpioneer.moneymaster.R&#10;import com.pixelpioneer.moneymaster.data.model.Transaction&#10;import com.pixelpioneer.moneymaster.data.model.TransactionCategory&#10;import com.pixelpioneer.moneymaster.data.repository.ReceiptScanRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for scanning receipts and extracting transaction items.&#10; *&#10; * Handles receipt image scanning, parsing OCR results into transactions,&#10; * and manages loading and error states for the scanning process.&#10; *&#10; * @property receiptScanRepository Repository for receipt scanning operations.&#10; */&#10;@HiltViewModel&#10;class ReceiptScanViewModel @Inject constructor(&#10;    private val receiptScanRepository: ReceiptScanRepository&#10;) : ViewModel() {&#10;&#10;    private val _scannedItems = MutableStateFlow&lt;List&lt;Transaction&gt;&gt;(emptyList())&#10;    val scannedItems: StateFlow&lt;List&lt;Transaction&gt;&gt; = _scannedItems&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error&#10;&#10;    fun scanReceipt(&#10;        imageFile: File,&#10;        defaultCategory: TransactionCategory,&#10;        context: Context&#10;    ) {&#10;        _isLoading.value = true&#10;        _error.value = null&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = receiptScanRepository.scanReceipt(imageFile)&#10;                Log.d(&quot;ReceiptScanViewModel&quot;, &quot;OCR Response: $response&quot;)&#10;&#10;                val parsedText = response.parsedResults?.firstOrNull()?.parsedText.orEmpty()&#10;&#10;                Log.d(&quot;ReceiptScanViewModel&quot;, &quot;OCR ParsedText: $parsedText&quot;)&#10;                if (parsedText.isBlank()) {&#10;                    _error.value = buildString {&#10;                        append(context.getString(R.string.error_no_text_recognized))&#10;                        append(&quot;\nOCRExitCode: ${response.ocrExitCode}\n&quot;)&#10;                        response.errorMessage?.let {&#10;                            if (it.toString().isNotBlank()) append(&quot;ErrorMessage: $it\n&quot;)&#10;                        }&#10;                        response.errorDetails?.let {&#10;                            if (it.toString().isNotBlank()) append(&quot;ErrorDetails: $it\n&quot;)&#10;                        }&#10;                    }&#10;                    _scannedItems.value = emptyList()&#10;                    return@launch&#10;                }&#10;&#10;                val items = parseItemsFromText(parsedText, defaultCategory)&#10;                if (items.isEmpty()) {&#10;                    _error.value = context.getString(R.string.error_no_item_recognized, parsedText)&#10;                }&#10;                _scannedItems.value = items&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;                Log.e(&quot;OCR_ERROR&quot;, &quot;Error scanning receipt&quot;, e)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun parseItemsFromText(&#10;        text: String,&#10;        defaultCategory: TransactionCategory&#10;    ): List&lt;Transaction&gt; {&#10;        val regex = Regex(&quot;&quot;&quot;(.+?)\s+(\d{1,3}[\.,]\d{2})&quot;&quot;&quot;)&#10;        val now = System.currentTimeMillis()&#10;&#10;        val excludeTerms = setOf(&#10;            &quot;zu zahlen&quot;,&#10;            &quot;summe&quot;,&#10;            &quot;total&quot;,&#10;            &quot;gesamt&quot;,&#10;            &quot;kreditkarte&quot;,&#10;            &quot;bargeld&quot;,&#10;            &quot;cash&quot;,&#10;            &quot;kartenzahlung&quot;,&#10;            &quot;rückgeld&quot;,&#10;            &quot;change&quot;,&#10;            &quot;mwst&quot;,&#10;            &quot;steuer&quot;,&#10;            &quot;tax&quot;,&#10;            &quot;rabatt&quot;,&#10;            &quot;discount&quot;,&#10;            &quot;gutschein&quot;,&#10;            &quot;coupon&quot;,&#10;            &quot;pfand&quot;,&#10;            &quot;deposit&quot;,&#10;            &quot;trinkgeld&quot;,&#10;            &quot;tip&quot;,&#10;            &quot;service&quot;,&#10;            &quot;beleg&quot;,&#10;            &quot;receipt&quot;,&#10;            &quot;quittung&quot;,&#10;            &quot;datum&quot;,&#10;            &quot;date&quot;,&#10;            &quot;zeit&quot;,&#10;            &quot;time&quot;,&#10;            &quot;uhrzeit&quot;,&#10;            &quot;kassierer&quot;,&#10;            &quot;cashier&quot;,&#10;            &quot;kasse&quot;,&#10;            &quot;register&quot;,&#10;            &quot;filiale&quot;,&#10;            &quot;branch&quot;,&#10;            &quot;store&quot;,&#10;            &quot;laden&quot;,&#10;            &quot;geschäft&quot;,&#10;            &quot;adresse&quot;,&#10;            &quot;address&quot;,&#10;            &quot;telefon&quot;,&#10;            &quot;phone&quot;,&#10;            &quot;tel&quot;,&#10;            &quot;fax&quot;,&#10;            &quot;email&quot;,&#10;            &quot;website&quot;,&#10;            &quot;www&quot;,&#10;            &quot;http&quot;,&#10;            &quot;danke&quot;,&#10;            &quot;thank&quot;,&#10;            &quot;vielen dank&quot;,&#10;            &quot;thank you&quot;,&#10;            &quot;auf wiedersehen&quot;,&#10;            &quot;goodbye&quot;,&#10;            &quot;tschüss&quot;,&#10;            &quot;bis bald&quot;,&#10;            &quot;preisvorteile&quot;,&#10;            &quot;savings&quot;,&#10;            &quot;ersparnis&quot;,&#10;            &quot;mehrwertsteuer&quot;,&#10;            &quot;ust-id&quot;,&#10;            &quot;tax-id&quot;,&#10;            &quot;steuernummer&quot;,&#10;            &quot;hnr&quot;,&#10;            &quot;str&quot;,&#10;            &quot;plz&quot;,&#10;            &quot;ort&quot;,&#10;            &quot;bar&quot;&#10;        )&#10;&#10;        return text.lines().mapNotNull { line -&gt;&#10;            val match = regex.find(line)&#10;            match?.let {&#10;                val (title, amountStr) = it.destructured&#10;                val cleanTitle = title.trim().lowercase()&#10;&#10;                if (excludeTerms.any { excludeTerm -&gt; cleanTitle.contains(excludeTerm) }) {&#10;                    return@let null&#10;                }&#10;&#10;                if (cleanTitle.length &lt; 3) {&#10;                    return@let null&#10;                }&#10;&#10;                if (cleanTitle.replace(&#10;                        Regex(&quot;[^a-zA-ZäöüßÄÖÜ]&quot;),&#10;                        &quot;&quot;&#10;                    ).length &lt; cleanTitle.length * 0.3&#10;                ) {&#10;                    return@let null&#10;                }&#10;&#10;                val amount = amountStr.replace(&quot;,&quot;, &quot;.&quot;).toDoubleOrNull() ?: return@let null&#10;&#10;                if (amount &lt; 0.10) {&#10;                    return@let null&#10;                }&#10;&#10;                Transaction(&#10;                    amount = amount,&#10;                    title = title.trim(),&#10;                    category = defaultCategory,&#10;                    date = now,&#10;                    isExpense = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.pixelpioneer.moneymaster.R&#10;import com.pixelpioneer.moneymaster.data.model.Transaction&#10;import com.pixelpioneer.moneymaster.data.model.TransactionCategory&#10;import com.pixelpioneer.moneymaster.data.repository.ReceiptScanRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for scanning receipts and extracting transaction items.&#10; *&#10; * Handles receipt image scanning, parsing OCR results into transactions,&#10; * and manages loading and error states for the scanning process.&#10; *&#10; * @property receiptScanRepository Repository for receipt scanning operations.&#10; */&#10;@HiltViewModel&#10;class ReceiptScanViewModel @Inject constructor(&#10;    private val receiptScanRepository: ReceiptScanRepository&#10;) : ViewModel() {&#10;&#10;    /**&#10;     * Contains the list of transactions extracted from the scanned receipt.&#10;     */&#10;    private val _scannedItems = MutableStateFlow&lt;List&lt;Transaction&gt;&gt;(emptyList())&#10;    &#10;    /**&#10;     * Public flow of scanned transaction items.&#10;     */&#10;    val scannedItems: StateFlow&lt;List&lt;Transaction&gt;&gt; = _scannedItems&#10;&#10;    /**&#10;     * Indicates whether a receipt scan is currently in progress.&#10;     */&#10;    private val _isLoading = MutableStateFlow(false)&#10;    &#10;    /**&#10;     * Public flow of loading state.&#10;     */&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading&#10;&#10;    /**&#10;     * Contains error message if scanning process fails.&#10;     */&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    &#10;    /**&#10;     * Public flow of error messages.&#10;     */&#10;    val error: StateFlow&lt;String?&gt; = _error&#10;&#10;    /**&#10;     * Scans a receipt image and extracts transaction items.&#10;     *&#10;     * @param imageFile The receipt image file to scan&#10;     * @param defaultCategory Default category to assign to extracted items&#10;     * @param context Context for accessing string resources&#10;     */&#10;    fun scanReceipt(&#10;        imageFile: File,&#10;        defaultCategory: TransactionCategory,&#10;        context: Context&#10;    ) {&#10;        _isLoading.value = true&#10;        _error.value = null&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = receiptScanRepository.scanReceipt(imageFile)&#10;                Log.d(&quot;ReceiptScanViewModel&quot;, &quot;OCR Response: $response&quot;)&#10;&#10;                val parsedText = response.parsedResults?.firstOrNull()?.parsedText.orEmpty()&#10;&#10;                Log.d(&quot;ReceiptScanViewModel&quot;, &quot;OCR ParsedText: $parsedText&quot;)&#10;                if (parsedText.isBlank()) {&#10;                    _error.value = buildString {&#10;                        append(context.getString(R.string.error_no_text_recognized))&#10;                        append(&quot;\nOCRExitCode: ${response.ocrExitCode}\n&quot;)&#10;                        response.errorMessage?.let {&#10;                            if (it.toString().isNotBlank()) append(&quot;ErrorMessage: $it\n&quot;)&#10;                        }&#10;                        response.errorDetails?.let {&#10;                            if (it.toString().isNotBlank()) append(&quot;ErrorDetails: $it\n&quot;)&#10;                        }&#10;                    }&#10;                    _scannedItems.value = emptyList()&#10;                    return@launch&#10;                }&#10;&#10;                val items = parseItemsFromText(parsedText, defaultCategory)&#10;                if (items.isEmpty()) {&#10;                    _error.value = context.getString(R.string.error_no_item_recognized, parsedText)&#10;                }&#10;                _scannedItems.value = items&#10;            } catch (e: Exception) {&#10;                _error.value = e.message&#10;                Log.e(&quot;OCR_ERROR&quot;, &quot;Error scanning receipt&quot;, e)&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parses OCR text to extract transaction items.&#10;     *&#10;     * Identifies item names and prices using regex pattern matching.&#10;     * Filters out common receipt terms that are not actual items.&#10;     *&#10;     * @param text The OCR-extracted text from receipt&#10;     * @param defaultCategory Default category to assign to extracted items&#10;     * @return List of Transaction objects representing items on the receipt&#10;     */&#10;    private fun parseItemsFromText(&#10;        text: String,&#10;        defaultCategory: TransactionCategory&#10;    ): List&lt;Transaction&gt; {&#10;        val regex = Regex(&quot;&quot;&quot;(.+?)\s+(\d{1,3}[\.,]\d{2})&quot;&quot;&quot;)&#10;        val now = System.currentTimeMillis()&#10;&#10;        val excludeTerms = setOf(&#10;            &quot;zu zahlen&quot;,&#10;            &quot;summe&quot;,&#10;            &quot;total&quot;,&#10;            &quot;gesamt&quot;,&#10;            &quot;kreditkarte&quot;,&#10;            &quot;bargeld&quot;,&#10;            &quot;cash&quot;,&#10;            &quot;kartenzahlung&quot;,&#10;            &quot;rückgeld&quot;,&#10;            &quot;change&quot;,&#10;            &quot;mwst&quot;,&#10;            &quot;steuer&quot;,&#10;            &quot;tax&quot;,&#10;            &quot;rabatt&quot;,&#10;            &quot;discount&quot;,&#10;            &quot;gutschein&quot;,&#10;            &quot;coupon&quot;,&#10;            &quot;pfand&quot;,&#10;            &quot;deposit&quot;,&#10;            &quot;trinkgeld&quot;,&#10;            &quot;tip&quot;,&#10;            &quot;service&quot;,&#10;            &quot;beleg&quot;,&#10;            &quot;receipt&quot;,&#10;            &quot;quittung&quot;,&#10;            &quot;datum&quot;,&#10;            &quot;date&quot;,&#10;            &quot;zeit&quot;,&#10;            &quot;time&quot;,&#10;            &quot;uhrzeit&quot;,&#10;            &quot;kassierer&quot;,&#10;            &quot;cashier&quot;,&#10;            &quot;kasse&quot;,&#10;            &quot;register&quot;,&#10;            &quot;filiale&quot;,&#10;            &quot;branch&quot;,&#10;            &quot;store&quot;,&#10;            &quot;laden&quot;,&#10;            &quot;geschäft&quot;,&#10;            &quot;adresse&quot;,&#10;            &quot;address&quot;,&#10;            &quot;telefon&quot;,&#10;            &quot;phone&quot;,&#10;            &quot;tel&quot;,&#10;            &quot;fax&quot;,&#10;            &quot;email&quot;,&#10;            &quot;website&quot;,&#10;            &quot;www&quot;,&#10;            &quot;http&quot;,&#10;            &quot;danke&quot;,&#10;            &quot;thank&quot;,&#10;            &quot;vielen dank&quot;,&#10;            &quot;thank you&quot;,&#10;            &quot;auf wiedersehen&quot;,&#10;            &quot;goodbye&quot;,&#10;            &quot;tschüss&quot;,&#10;            &quot;bis bald&quot;,&#10;            &quot;preisvorteile&quot;,&#10;            &quot;savings&quot;,&#10;            &quot;ersparnis&quot;,&#10;            &quot;mehrwertsteuer&quot;,&#10;            &quot;ust-id&quot;,&#10;            &quot;tax-id&quot;,&#10;            &quot;steuernummer&quot;,&#10;            &quot;hnr&quot;,&#10;            &quot;str&quot;,&#10;            &quot;plz&quot;,&#10;            &quot;ort&quot;,&#10;            &quot;bar&quot;&#10;        )&#10;&#10;        return text.lines().mapNotNull { line -&gt;&#10;            val match = regex.find(line)&#10;            match?.let {&#10;                val (title, amountStr) = it.destructured&#10;                val cleanTitle = title.trim().lowercase()&#10;&#10;                if (excludeTerms.any { excludeTerm -&gt; cleanTitle.contains(excludeTerm) }) {&#10;                    return@let null&#10;                }&#10;&#10;                if (cleanTitle.length &lt; 3) {&#10;                    return@let null&#10;                }&#10;&#10;                if (cleanTitle.replace(&#10;                        Regex(&quot;[^a-zA-ZäöüßÄÖÜ]&quot;),&#10;                        &quot;&quot;&#10;                    ).length &lt; cleanTitle.length * 0.3&#10;                ) {&#10;                    return@let null&#10;                }&#10;&#10;                val amount = amountStr.replace(&quot;,&quot;, &quot;.&quot;).toDoubleOrNull() ?: return@let null&#10;&#10;                if (amount &lt; 0.10) {&#10;                    return@let null&#10;                }&#10;&#10;                Transaction(&#10;                    amount = amount,&#10;                    title = title.trim(),&#10;                    category = defaultCategory,&#10;                    date = now,&#10;                    isExpense = true&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/SettingsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/SettingsViewModel.kt" />
              <option name="originalContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import com.pixelpioneer.moneymaster.data.model.SettingsState&#10;import com.pixelpioneer.moneymaster.data.repository.SettingsRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for managing user settings and preferences.&#10; *&#10; * Handles loading, updating, and persisting user settings such as name, income,&#10; * recurring costs, and appearance preferences. Provides a state flow for the current settings.&#10; *&#10; * @property settingsRepository Repository for accessing and saving settings.&#10; */&#10;@HiltViewModel&#10;class SettingsViewModel @Inject constructor(&#10;    private val settingsRepository: SettingsRepository&#10;) : ViewModel() {&#10;    private val _state = MutableStateFlow(loadSettings())&#10;    val state: StateFlow&lt;SettingsState&gt; = _state&#10;&#10;    private fun loadSettings(): SettingsState = SettingsState(&#10;        name = settingsRepository.getName(),&#10;        income = settingsRepository.getIncome(),&#10;        rent = settingsRepository.getRent(),&#10;        electricity = settingsRepository.getElectricity(),&#10;        gas = settingsRepository.getGas(),&#10;        internet = settingsRepository.getInternet(),&#10;        darkMode = settingsRepository.isDarkMode(),&#10;        additionalCosts = settingsRepository.getAdditionalCosts()&#10;    )&#10;&#10;    fun updateName(name: String) {&#10;        _state.value = _state.value.copy(name = name)&#10;        settingsRepository.saveName(name)&#10;    }&#10;&#10;    fun updateIncome(income: String) {&#10;        _state.value = _state.value.copy(income = income)&#10;        settingsRepository.saveIncome(income)&#10;    }&#10;&#10;    fun updateRent(rent: String) {&#10;        _state.value = _state.value.copy(rent = rent)&#10;        settingsRepository.saveRent(rent)&#10;    }&#10;&#10;    fun updateElectricity(electricity: String) {&#10;        _state.value = _state.value.copy(electricity = electricity)&#10;        settingsRepository.saveElectricity(electricity)&#10;    }&#10;&#10;    fun updateGas(gas: String) {&#10;        _state.value = _state.value.copy(gas = gas)&#10;        settingsRepository.saveGas(gas)&#10;    }&#10;&#10;    fun updateInternet(internet: String) {&#10;        _state.value = _state.value.copy(internet = internet)&#10;        settingsRepository.saveInternet(internet)&#10;    }&#10;&#10;    fun updateDarkMode(dark: Boolean) {&#10;        _state.value = _state.value.copy(darkMode = dark)&#10;        settingsRepository.saveDarkMode(dark)&#10;    }&#10;&#10;    fun addAdditionalCost() {&#10;        val updated =&#10;            _state.value.additionalCosts + com.pixelpioneer.moneymaster.data.model.AdditionalCost()&#10;        _state.value = _state.value.copy(additionalCosts = updated)&#10;        settingsRepository.saveAdditionalCosts(updated)&#10;    }&#10;&#10;    fun updateAdditionalCost(index: Int, label: String? = null, value: String? = null) {&#10;        val costs = _state.value.additionalCosts.toMutableList()&#10;        val current = costs.getOrNull(index) ?: return&#10;        costs[index] = current.copy(&#10;            label = label ?: current.label,&#10;            value = value ?: current.value&#10;        )&#10;        _state.value = _state.value.copy(additionalCosts = costs)&#10;        settingsRepository.saveAdditionalCosts(costs)&#10;    }&#10;&#10;    fun removeAdditionalCost(index: Int) {&#10;        val costs = _state.value.additionalCosts.toMutableList()&#10;        if (index in costs.indices) {&#10;            costs.removeAt(index)&#10;            _state.value = _state.value.copy(additionalCosts = costs)&#10;            settingsRepository.saveAdditionalCosts(costs)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import com.pixelpioneer.moneymaster.data.model.SettingsState&#10;import com.pixelpioneer.moneymaster.data.repository.SettingsRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for managing user settings and preferences.&#10; *&#10; * Handles loading, updating, and persisting user settings such as name, income,&#10; * recurring costs, and appearance preferences. Provides a state flow for the current settings.&#10; *&#10; * @property settingsRepository Repository for accessing and saving settings.&#10; */&#10;@HiltViewModel&#10;class SettingsViewModel @Inject constructor(&#10;    private val settingsRepository: SettingsRepository&#10;) : ViewModel() {&#10;    /**&#10;     * Internal mutable state of user settings.&#10;     */&#10;    private val _state = MutableStateFlow(loadSettings())&#10;    &#10;    /**&#10;     * Public state flow of user settings.&#10;     */&#10;    val state: StateFlow&lt;SettingsState&gt; = _state&#10;&#10;    /**&#10;     * Loads settings from the repository into a SettingsState object.&#10;     *&#10;     * @return SettingsState containing all user settings&#10;     */&#10;    private fun loadSettings(): SettingsState = SettingsState(&#10;        name = settingsRepository.getName(),&#10;        income = settingsRepository.getIncome(),&#10;        rent = settingsRepository.getRent(),&#10;        electricity = settingsRepository.getElectricity(),&#10;        gas = settingsRepository.getGas(),&#10;        internet = settingsRepository.getInternet(),&#10;        darkMode = settingsRepository.isDarkMode(),&#10;        additionalCosts = settingsRepository.getAdditionalCosts()&#10;    )&#10;&#10;    /**&#10;     * Updates the user's name setting.&#10;     *&#10;     * @param name The new name value&#10;     */&#10;    fun updateName(name: String) {&#10;        _state.value = _state.value.copy(name = name)&#10;        settingsRepository.saveName(name)&#10;    }&#10;&#10;    /**&#10;     * Updates the user's income setting.&#10;     *&#10;     * @param income The new income value&#10;     */&#10;    fun updateIncome(income: String) {&#10;        _state.value = _state.value.copy(income = income)&#10;        settingsRepository.saveIncome(income)&#10;    }&#10;&#10;    /**&#10;     * Updates the user's rent setting.&#10;     *&#10;     * @param rent The new rent value&#10;     */&#10;    fun updateRent(rent: String) {&#10;        _state.value = _state.value.copy(rent = rent)&#10;        settingsRepository.saveRent(rent)&#10;    }&#10;&#10;    /**&#10;     * Updates the user's electricity cost setting.&#10;     *&#10;     * @param electricity The new electricity cost value&#10;     */&#10;    fun updateElectricity(electricity: String) {&#10;        _state.value = _state.value.copy(electricity = electricity)&#10;        settingsRepository.saveElectricity(electricity)&#10;    }&#10;&#10;    /**&#10;     * Updates the user's gas cost setting.&#10;     *&#10;     * @param gas The new gas cost value&#10;     */&#10;    fun updateGas(gas: String) {&#10;        _state.value = _state.value.copy(gas = gas)&#10;        settingsRepository.saveGas(gas)&#10;    }&#10;&#10;    /**&#10;     * Updates the user's internet cost setting.&#10;     *&#10;     * @param internet The new internet cost value&#10;     */&#10;    fun updateInternet(internet: String) {&#10;        _state.value = _state.value.copy(internet = internet)&#10;        settingsRepository.saveInternet(internet)&#10;    }&#10;&#10;    /**&#10;     * Updates the dark mode preference.&#10;     *&#10;     * @param dark Whether dark mode should be enabled&#10;     */&#10;    fun updateDarkMode(dark: Boolean) {&#10;        _state.value = _state.value.copy(darkMode = dark)&#10;        settingsRepository.saveDarkMode(dark)&#10;    }&#10;&#10;    /**&#10;     * Adds a new additional cost entry.&#10;     */&#10;    fun addAdditionalCost() {&#10;        val updated =&#10;            _state.value.additionalCosts + com.pixelpioneer.moneymaster.data.model.AdditionalCost()&#10;        _state.value = _state.value.copy(additionalCosts = updated)&#10;        settingsRepository.saveAdditionalCosts(updated)&#10;    }&#10;&#10;    /**&#10;     * Updates an additional cost at the specified index.&#10;     *&#10;     * @param index The index of the additional cost to update&#10;     * @param label The new label for the cost, or null to keep current value&#10;     * @param value The new cost value, or null to keep current value&#10;     */&#10;    fun updateAdditionalCost(index: Int, label: String? = null, value: String? = null) {&#10;        val costs = _state.value.additionalCosts.toMutableList()&#10;        val current = costs.getOrNull(index) ?: return&#10;        costs[index] = current.copy(&#10;            label = label ?: current.label,&#10;            value = value ?: current.value&#10;        )&#10;        _state.value = _state.value.copy(additionalCosts = costs)&#10;        settingsRepository.saveAdditionalCosts(costs)&#10;    }&#10;&#10;    /**&#10;     * Removes an additional cost at the specified index.&#10;     *&#10;     * @param index The index of the additional cost to remove&#10;     */&#10;    fun removeAdditionalCost(index: Int) {&#10;        val costs = _state.value.additionalCosts.toMutableList()&#10;        if (index in costs.indices) {&#10;            costs.removeAt(index)&#10;            _state.value = _state.value.copy(additionalCosts = costs)&#10;            settingsRepository.saveAdditionalCosts(costs)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/StatisticsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/StatisticsViewModel.kt" />
              <option name="originalContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.pixelpioneer.moneymaster.R&#10;import com.pixelpioneer.moneymaster.core.util.UiState&#10;import com.pixelpioneer.moneymaster.data.model.CategoryStats&#10;import com.pixelpioneer.moneymaster.data.model.MonthlyTrend&#10;import com.pixelpioneer.moneymaster.data.model.StatisticsOverview&#10;import com.pixelpioneer.moneymaster.data.repository.CategoryRepository&#10;import com.pixelpioneer.moneymaster.data.repository.TransactionRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Calendar&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for managing and calculating statistics related to transactions and categories.&#10; *&#10; * Loads statistical overviews, category statistics, and monthly trends.&#10; * Provides UI state flows for statistics and trends.&#10; *&#10; * @property transactionRepository Repository for transaction data access.&#10; * @property categoryRepository Repository for category data access.&#10; * @property context Application context for accessing resources.&#10; */&#10;@HiltViewModel&#10;class StatisticsViewModel @Inject constructor(&#10;    private val transactionRepository: TransactionRepository,&#10;    private val categoryRepository: CategoryRepository,&#10;    @ApplicationContext private val context: Context&#10;) : ViewModel() {&#10;&#10;    private val _statisticsState = MutableStateFlow&lt;UiState&lt;StatisticsOverview&gt;&gt;(UiState.Loading)&#10;    val statisticsState: StateFlow&lt;UiState&lt;StatisticsOverview&gt;&gt; = _statisticsState&#10;&#10;    private val _categoryStatsState =&#10;        MutableStateFlow&lt;UiState&lt;List&lt;CategoryStats&gt;&gt;&gt;(UiState.Loading)&#10;    val categoryStatsState: StateFlow&lt;UiState&lt;List&lt;CategoryStats&gt;&gt;&gt; = _categoryStatsState&#10;&#10;    private val _monthlyTrendsState = MutableStateFlow&lt;UiState&lt;List&lt;MonthlyTrend&gt;&gt;&gt;(UiState.Loading)&#10;    val monthlyTrendsState: StateFlow&lt;UiState&lt;List&lt;MonthlyTrend&gt;&gt;&gt; = _monthlyTrendsState&#10;&#10;    init {&#10;        loadStatistics()&#10;        loadCategoryStats()&#10;        loadMonthlyTrends()&#10;    }&#10;&#10;    private fun loadStatistics() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _statisticsState.value = UiState.Loading&#10;&#10;                val calendar = Calendar.getInstance()&#10;                val currentMonth = calendar.apply {&#10;                    set(Calendar.DAY_OF_MONTH, 1)&#10;                    set(Calendar.HOUR_OF_DAY, 0)&#10;                    set(Calendar.MINUTE, 0)&#10;                    set(Calendar.SECOND, 0)&#10;                    set(Calendar.MILLISECOND, 0)&#10;                }.timeInMillis&#10;&#10;                val nextMonth = calendar.apply {&#10;                    add(Calendar.MONTH, 1)&#10;                }.timeInMillis&#10;&#10;                transactionRepository.getTransactionsWithCategoryByDateRange(&#10;                    currentMonth,&#10;                    nextMonth&#10;                )&#10;                    .catch { e -&gt;&#10;                        _statisticsState.value =&#10;                            UiState.Error(&#10;                                e.message ?: context.getString(R.string.error_loading_statistics)&#10;                            )&#10;                    }&#10;                    .collect { transactions -&gt;&#10;                        transactionRepository.getTotalIncomeSync()&#10;                        transactionRepository.getTotalExpensesSync()&#10;                        val totalTransactions = transactionRepository.getTransactionCountSync()&#10;&#10;                        val monthlyIncome = transactions&#10;                            .filter { !it.transaction.isExpense }&#10;                            .sumOf { it.transaction.amount }&#10;&#10;                        val monthlyExpenses = transactions&#10;                            .filter { it.transaction.isExpense }&#10;                            .sumOf { it.transaction.amount }&#10;&#10;                        val monthlyBalance = monthlyIncome - monthlyExpenses&#10;&#10;                        val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;                        val avgDailyExpenses = monthlyExpenses / daysInMonth&#10;                        val avgWeeklyExpenses = avgDailyExpenses * 7&#10;&#10;                        val overview = StatisticsOverview(&#10;                            monthlyIncome = monthlyIncome,&#10;                            monthlyExpenses = monthlyExpenses,&#10;                            monthlyBalance = monthlyBalance,&#10;                            avgDailyExpenses = avgDailyExpenses,&#10;                            avgWeeklyExpenses = avgWeeklyExpenses,&#10;                            totalTransactions = totalTransactions,&#10;                            monthlyTransactions = transactions.size&#10;                        )&#10;&#10;                        _statisticsState.value = UiState.Success(overview)&#10;                    }&#10;            } catch (e: Exception) {&#10;                _statisticsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadCategoryStats() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _categoryStatsState.value = UiState.Loading&#10;&#10;                combine(&#10;                    categoryRepository.allCategories,&#10;                    transactionRepository.allTransactionsWithCategory&#10;                ) { categories, transactions -&gt;&#10;                    val expenseTransactions = transactions.filter { it.isExpense }&#10;&#10;                    categories.mapNotNull { category -&gt;&#10;                        val categoryTransactions =&#10;                            expenseTransactions.filter { it.category.id == category.id }&#10;                        if (categoryTransactions.isNotEmpty()) {&#10;                            CategoryStats(&#10;                                category = category,&#10;                                amount = categoryTransactions.sumOf { it.amount.toDouble() },&#10;                                transactionCount = categoryTransactions.size&#10;                            )&#10;                        } else null&#10;                    }.sortedByDescending { it.amount }&#10;                }&#10;                    .catch { e -&gt;&#10;                        _categoryStatsState.value = UiState.Error(&#10;                            e.message&#10;                                ?: context.getString(R.string.error_loading_category_statistics)&#10;                        )&#10;                    }&#10;                    .collect { categoryStats -&gt;&#10;                        if (categoryStats.isEmpty()) {&#10;                            _categoryStatsState.value = UiState.Empty&#10;                        } else {&#10;                            _categoryStatsState.value = UiState.Success(categoryStats)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _categoryStatsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadMonthlyTrends() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _monthlyTrendsState.value = UiState.Loading&#10;&#10;                transactionRepository.allTransactionsWithCategory&#10;                    .catch { e -&gt;&#10;                        _monthlyTrendsState.value =&#10;                            UiState.Error(&#10;                                e.message ?: context.getString(R.string.error_loading_trend_data)&#10;                            )&#10;                    }&#10;                    .collect { transactions -&gt;&#10;                        val monthlyTrends = transactions&#10;                            .groupBy { transactionWithCategory -&gt;&#10;                                val calendar = Calendar.getInstance()&#10;                                calendar.timeInMillis = transactionWithCategory.date&#10;                                &quot;${calendar.get(Calendar.YEAR)}-${calendar.get(Calendar.MONTH)}&quot;&#10;                            }&#10;                            .map { (_, monthTransactions) -&gt;&#10;                                val calendar = Calendar.getInstance()&#10;                                calendar.timeInMillis = monthTransactions.first().date&#10;&#10;                                val monthlyIncome = transactions&#10;                                    .filter { !it.isExpense }&#10;                                    .sumOf { it.amount }&#10;&#10;                                val monthlyExpenses = transactions&#10;                                    .filter { it.isExpense }&#10;                                    .sumOf { it.amount }&#10;&#10;                                val dateFormat = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.GERMAN)&#10;                                val monthYear = dateFormat.format(calendar.time)&#10;&#10;                                MonthlyTrend(&#10;                                    monthYear = monthYear,&#10;                                    income = monthlyIncome,&#10;                                    expenses = monthlyExpenses,&#10;                                    balance = monthlyIncome - monthlyExpenses,&#10;                                    transactionCount = monthTransactions.size&#10;                                )&#10;                            }&#10;                            .sortedWith(compareByDescending&lt;MonthlyTrend&gt; { trend -&gt;&#10;                                SimpleDateFormat(&#10;                                    &quot;MMMM yyyy&quot;,&#10;                                    Locale.GERMAN&#10;                                ).parse(trend.monthYear)?.time ?: 0&#10;                            })&#10;                            .take(12)&#10;&#10;                        if (monthlyTrends.isEmpty()) {&#10;                            _monthlyTrendsState.value = UiState.Empty&#10;                        } else {&#10;                            _monthlyTrendsState.value = UiState.Success(monthlyTrends)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _monthlyTrendsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.pixelpioneer.moneymaster.R&#10;import com.pixelpioneer.moneymaster.core.util.UiState&#10;import com.pixelpioneer.moneymaster.data.model.CategoryStats&#10;import com.pixelpioneer.moneymaster.data.model.MonthlyTrend&#10;import com.pixelpioneer.moneymaster.data.model.StatisticsOverview&#10;import com.pixelpioneer.moneymaster.data.repository.CategoryRepository&#10;import com.pixelpioneer.moneymaster.data.repository.TransactionRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Calendar&#10;import java.util.Locale&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for managing and calculating statistics related to transactions and categories.&#10; *&#10; * Loads statistical overviews, category statistics, and monthly trends.&#10; * Provides UI state flows for statistics and trends.&#10; *&#10; * @property transactionRepository Repository for transaction data access.&#10; * @property categoryRepository Repository for category data access.&#10; * @property context Application context for accessing resources.&#10; */&#10;@HiltViewModel&#10;class StatisticsViewModel @Inject constructor(&#10;    private val transactionRepository: TransactionRepository,&#10;    private val categoryRepository: CategoryRepository,&#10;    @ApplicationContext private val context: Context&#10;) : ViewModel() {&#10;&#10;    private val _statisticsState = MutableStateFlow&lt;UiState&lt;StatisticsOverview&gt;&gt;(UiState.Loading)&#10;    val statisticsState: StateFlow&lt;UiState&lt;StatisticsOverview&gt;&gt; = _statisticsState&#10;&#10;    private val _categoryStatsState =&#10;        MutableStateFlow&lt;UiState&lt;List&lt;CategoryStats&gt;&gt;&gt;(UiState.Loading)&#10;    val categoryStatsState: StateFlow&lt;UiState&lt;List&lt;CategoryStats&gt;&gt;&gt; = _categoryStatsState&#10;&#10;    private val _monthlyTrendsState = MutableStateFlow&lt;UiState&lt;List&lt;MonthlyTrend&gt;&gt;&gt;(UiState.Loading)&#10;    val monthlyTrendsState: StateFlow&lt;UiState&lt;List&lt;MonthlyTrend&gt;&gt;&gt; = _monthlyTrendsState&#10;&#10;    init {&#10;        loadStatistics()&#10;        loadCategoryStats()&#10;        loadMonthlyTrends()&#10;    }&#10;&#10;    /**&#10;     * Loads general statistics data including monthly income, expenses, and balance.&#10;     * Calculates daily and weekly expense averages.&#10;     */&#10;    private fun loadStatistics() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _statisticsState.value = UiState.Loading&#10;&#10;                val calendar = Calendar.getInstance()&#10;                val currentMonth = calendar.apply {&#10;                    set(Calendar.DAY_OF_MONTH, 1)&#10;                    set(Calendar.HOUR_OF_DAY, 0)&#10;                    set(Calendar.MINUTE, 0)&#10;                    set(Calendar.SECOND, 0)&#10;                    set(Calendar.MILLISECOND, 0)&#10;                }.timeInMillis&#10;&#10;                val nextMonth = calendar.apply {&#10;                    add(Calendar.MONTH, 1)&#10;                }.timeInMillis&#10;&#10;                transactionRepository.getTransactionsWithCategoryByDateRange(&#10;                    currentMonth,&#10;                    nextMonth&#10;                )&#10;                    .catch { e -&gt;&#10;                        _statisticsState.value =&#10;                            UiState.Error(&#10;                                e.message ?: context.getString(R.string.error_loading_statistics)&#10;                            )&#10;                    }&#10;                    .collect { transactions -&gt;&#10;                        transactionRepository.getTotalIncomeSync()&#10;                        transactionRepository.getTotalExpensesSync()&#10;                        val totalTransactions = transactionRepository.getTransactionCountSync()&#10;&#10;                        val monthlyIncome = transactions&#10;                            .filter { !it.transaction.isExpense }&#10;                            .sumOf { it.transaction.amount }&#10;&#10;                        val monthlyExpenses = transactions&#10;                            .filter { it.transaction.isExpense }&#10;                            .sumOf { it.transaction.amount }&#10;&#10;                        val monthlyBalance = monthlyIncome - monthlyExpenses&#10;&#10;                        val daysInMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH)&#10;                        val avgDailyExpenses = monthlyExpenses / daysInMonth&#10;                        val avgWeeklyExpenses = avgDailyExpenses * 7&#10;&#10;                        val overview = StatisticsOverview(&#10;                            monthlyIncome = monthlyIncome,&#10;                            monthlyExpenses = monthlyExpenses,&#10;                            monthlyBalance = monthlyBalance,&#10;                            avgDailyExpenses = avgDailyExpenses,&#10;                            avgWeeklyExpenses = avgWeeklyExpenses,&#10;                            totalTransactions = totalTransactions,&#10;                            monthlyTransactions = transactions.size&#10;                        )&#10;&#10;                        _statisticsState.value = UiState.Success(overview)&#10;                    }&#10;            } catch (e: Exception) {&#10;                _statisticsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Loads statistics for each category, including total amount and transaction count.&#10;     */&#10;    private fun loadCategoryStats() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _categoryStatsState.value = UiState.Loading&#10;&#10;                combine(&#10;                    categoryRepository.allCategories,&#10;                    transactionRepository.allTransactionsWithCategory&#10;                ) { categories, transactions -&gt;&#10;                    val expenseTransactions = transactions.filter { it.isExpense }&#10;&#10;                    categories.mapNotNull { category -&gt;&#10;                        val categoryTransactions =&#10;                            expenseTransactions.filter { it.category.id == category.id }&#10;                        if (categoryTransactions.isNotEmpty()) {&#10;                            CategoryStats(&#10;                                category = category,&#10;                                amount = categoryTransactions.sumOf { it.amount.toDouble() },&#10;                                transactionCount = categoryTransactions.size&#10;                            )&#10;                        } else null&#10;                    }.sortedByDescending { it.amount }&#10;                }&#10;                    .catch { e -&gt;&#10;                        _categoryStatsState.value = UiState.Error(&#10;                            e.message&#10;                                ?: context.getString(R.string.error_loading_category_statistics)&#10;                        )&#10;                    }&#10;                    .collect { categoryStats -&gt;&#10;                        if (categoryStats.isEmpty()) {&#10;                            _categoryStatsState.value = UiState.Empty&#10;                        } else {&#10;                            _categoryStatsState.value = UiState.Success(categoryStats)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _categoryStatsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Loads monthly trends data showing income, expenses, and transaction count by month.&#10;     */&#10;    private fun loadMonthlyTrends() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _monthlyTrendsState.value = UiState.Loading&#10;&#10;                transactionRepository.allTransactionsWithCategory&#10;                    .catch { e -&gt;&#10;                        _monthlyTrendsState.value =&#10;                            UiState.Error(&#10;                                e.message ?: context.getString(R.string.error_loading_trend_data)&#10;                            )&#10;                    }&#10;                    .collect { transactions -&gt;&#10;                        val monthlyTrends = transactions&#10;                            .groupBy { transactionWithCategory -&gt;&#10;                                val calendar = Calendar.getInstance()&#10;                                calendar.timeInMillis = transactionWithCategory.date&#10;                                &quot;${calendar.get(Calendar.YEAR)}-${calendar.get(Calendar.MONTH)}&quot;&#10;                            }&#10;                            .map { (_, monthTransactions) -&gt;&#10;                                val calendar = Calendar.getInstance()&#10;                                calendar.timeInMillis = monthTransactions.first().date&#10;&#10;                                val monthlyIncome = transactions&#10;                                    .filter { !it.isExpense }&#10;                                    .sumOf { it.amount }&#10;&#10;                                val monthlyExpenses = transactions&#10;                                    .filter { it.isExpense }&#10;                                    .sumOf { it.amount }&#10;&#10;                                val dateFormat = SimpleDateFormat(&quot;MMMM yyyy&quot;, Locale.GERMAN)&#10;                                val monthYear = dateFormat.format(calendar.time)&#10;&#10;                                MonthlyTrend(&#10;                                    monthYear = monthYear,&#10;                                    income = monthlyIncome,&#10;                                    expenses = monthlyExpenses,&#10;                                    balance = monthlyIncome - monthlyExpenses,&#10;                                    transactionCount = monthTransactions.size&#10;                                )&#10;                            }&#10;                            .sortedWith(compareByDescending&lt;MonthlyTrend&gt; { trend -&gt;&#10;                                SimpleDateFormat(&#10;                                    &quot;MMMM yyyy&quot;,&#10;                                    Locale.GERMAN&#10;                                ).parse(trend.monthYear)?.time ?: 0&#10;                            })&#10;                            .take(12)&#10;&#10;                        if (monthlyTrends.isEmpty()) {&#10;                            _monthlyTrendsState.value = UiState.Empty&#10;                        } else {&#10;                            _monthlyTrendsState.value = UiState.Success(monthlyTrends)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _monthlyTrendsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/TransactionViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/pixelpioneer/moneymaster/ui/viewmodel/TransactionViewModel.kt" />
              <option name="originalContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.pixelpioneer.moneymaster.R&#10;import com.pixelpioneer.moneymaster.core.util.UiState&#10;import com.pixelpioneer.moneymaster.data.model.FinancialSummary&#10;import com.pixelpioneer.moneymaster.data.model.Receipt&#10;import com.pixelpioneer.moneymaster.data.model.Transaction&#10;import com.pixelpioneer.moneymaster.data.model.TransactionCategory&#10;import com.pixelpioneer.moneymaster.data.model.TransactionFormState&#10;import com.pixelpioneer.moneymaster.data.repository.CategoryRepository&#10;import com.pixelpioneer.moneymaster.data.repository.TransactionRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for managing transactions and related financial data.&#10; *&#10; * Handles loading, creating, updating, and deleting transactions,&#10; * as well as managing categories, form state, and financial summaries.&#10; * Provides UI state flows for transactions and summaries.&#10; *&#10; * @property transactionRepository Repository for transaction data access.&#10; * @property categoryRepository Repository for category data access.&#10; * @property context Application context for accessing resources.&#10; */&#10;@HiltViewModel&#10;class TransactionViewModel @Inject constructor(&#10;    private val transactionRepository: TransactionRepository,&#10;    private val categoryRepository: CategoryRepository,&#10;    @ApplicationContext private val context: Context&#10;) : ViewModel() {&#10;    private val _transactionsState = MutableStateFlow&lt;UiState&lt;List&lt;Transaction&gt;&gt;&gt;(UiState.Loading)&#10;    val transactionsState: StateFlow&lt;UiState&lt;List&lt;Transaction&gt;&gt;&gt; = _transactionsState&#10;&#10;    private val _categoriesState =&#10;        MutableStateFlow&lt;UiState&lt;List&lt;TransactionCategory&gt;&gt;&gt;(UiState.Loading)&#10;    val categoriesState: StateFlow&lt;UiState&lt;List&lt;TransactionCategory&gt;&gt;&gt; = _categoriesState&#10;&#10;    private val _selectedTransaction = MutableStateFlow&lt;UiState&lt;Transaction&gt;&gt;(UiState.Loading)&#10;    val selectedTransaction: StateFlow&lt;UiState&lt;Transaction&gt;&gt; = _selectedTransaction&#10;&#10;    private val _transactionFormState = MutableStateFlow(TransactionFormState())&#10;    val transactionFormState: StateFlow&lt;TransactionFormState&gt; = _transactionFormState&#10;&#10;    private val _financialSummary = MutableStateFlow&lt;UiState&lt;FinancialSummary&gt;&gt;(UiState.Loading)&#10;    val financialSummary: StateFlow&lt;UiState&lt;FinancialSummary&gt;&gt; = _financialSummary&#10;&#10;    init {&#10;        loadTransactions()&#10;        loadCategories()&#10;        loadFinancialSummary()&#10;    }&#10;&#10;    private fun loadTransactions() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _transactionsState.value = UiState.Loading&#10;                transactionRepository.allTransactionsWithCategory&#10;                    .catch { e -&gt;&#10;                        _transactionsState.value =&#10;                            UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;                    }&#10;                    .collect { transactions -&gt;&#10;                        if (transactions.isEmpty()) {&#10;                            _transactionsState.value = UiState.Empty&#10;                        } else {&#10;                            _transactionsState.value = UiState.Success(transactions)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _transactionsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadTransactionById(id: Long) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _selectedTransaction.value = UiState.Loading&#10;                transactionRepository.getTransactionById(id)&#10;                    .catch { e -&gt;&#10;                        _selectedTransaction.value =&#10;                            UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;                    }&#10;                    .collect { transaction -&gt;&#10;                        _selectedTransaction.value = UiState.Success(transaction)&#10;                    }&#10;            } catch (e: Exception) {&#10;                _selectedTransaction.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadCategories() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _categoriesState.value = UiState.Loading&#10;                categoryRepository.allCategories&#10;                    .catch { e -&gt;&#10;                        _categoriesState.value =&#10;                            UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;                    }&#10;                    .collect { categories -&gt;&#10;                        if (categories.isEmpty()) {&#10;                            _categoriesState.value = UiState.Empty&#10;                        } else {&#10;                            _categoriesState.value = UiState.Success(categories)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _categoriesState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadFinancialSummary() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _financialSummary.value = UiState.Loading&#10;&#10;                combine(&#10;                    transactionRepository.getTotalIncomeByMonth(),&#10;                    transactionRepository.getTotalExpensesByMonth()&#10;                ) { income, expenses -&gt;&#10;                    val balance = income - expenses&#10;                    FinancialSummary(&#10;                        totalIncome = income,&#10;                        totalExpenses = expenses,&#10;                        balance = balance&#10;                    )&#10;                }.catch { e -&gt;&#10;                    _financialSummary.value = UiState.Error(&#10;                        e.message ?: context.getString(R.string.error_unknown)&#10;                    )&#10;                }.collect { summary -&gt;&#10;                    _financialSummary.value = UiState.Success(summary)&#10;                }&#10;            } catch (e: Exception) {&#10;                _financialSummary.value = UiState.Error(&#10;                    e.message ?: context.getString(R.string.error_unknown)&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun createTransaction(onComplete: () -&gt; Unit = {}) {&#10;        viewModelScope.launch {&#10;            val formState = _transactionFormState.value&#10;&#10;            if (!validateTransactionForm()) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                val category = _transactionFormState.value.selectedCategory&#10;                    ?: throw IllegalStateException(&quot;Category cannot be null&quot;)&#10;&#10;                val transaction = Transaction(&#10;                    amount = formState.amount,&#10;                    title = formState.title,&#10;                    description = formState.description,&#10;                    category = category,&#10;                    date = formState.date,&#10;                    isExpense = formState.isExpense&#10;                )&#10;&#10;                transactionRepository.insertTransaction(transaction)&#10;                resetFormState()&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;                onComplete()&#10;            } catch (e: Exception) {&#10;                // Error handling&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    fun updateTransaction(id: Long) {&#10;        viewModelScope.launch {&#10;            val formState = _transactionFormState.value&#10;&#10;            if (!validateTransactionForm()) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                val category = _transactionFormState.value.selectedCategory&#10;                    ?: throw IllegalStateException(&quot;Category cannot be null&quot;)&#10;&#10;                val transaction = Transaction(&#10;                    id = id,&#10;                    amount = formState.amount,&#10;                    title = formState.title,&#10;                    description = formState.description,&#10;                    category = category,&#10;                    date = formState.date,&#10;                    isExpense = formState.isExpense&#10;                )&#10;&#10;                transactionRepository.updateTransaction(transaction)&#10;&#10;                resetFormState()&#10;&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;&#10;                loadTransactionById(id)&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteTransaction(transaction: Transaction) {&#10;        viewModelScope.launch {&#10;            try {&#10;                transactionRepository.deleteTransaction(transaction)&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateAmount(amount: Double) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(&#10;            amount = amount,&#10;            amountError = if (amount &lt;= 0) context.getString(R.string.error_amount_greater_zero) else null&#10;        )&#10;    }&#10;&#10;    fun updateTitle(title: String) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(&#10;            title = title,&#10;            titleError = if (title.isBlank()) context.getString(R.string.error_title_empty) else null&#10;        )&#10;    }&#10;&#10;    fun updateDescription(description: String) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(description = description)&#10;    }&#10;&#10;    fun updateSelectedCategory(category: TransactionCategory) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(&#10;            selectedCategory = category,&#10;            categoryError = null&#10;        )&#10;    }&#10;&#10;    fun updateDate(date: Long) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(date = date)&#10;    }&#10;&#10;    fun updateIsExpense(isExpense: Boolean) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(isExpense = isExpense)&#10;    }&#10;&#10;    fun initFormWithTransaction(transaction: Transaction) {&#10;        _transactionFormState.value = TransactionFormState(&#10;            amount = transaction.amount,&#10;            title = transaction.title,&#10;            description = transaction.description,&#10;            selectedCategory = transaction.category,&#10;            date = transaction.date,&#10;            isExpense = transaction.isExpense&#10;        )&#10;    }&#10;&#10;    private fun validateTransactionForm(): Boolean {&#10;        val formState = _transactionFormState.value&#10;        var isValid = true&#10;&#10;        var updatedFormState = formState&#10;&#10;        if (formState.amount &lt;= 0) {&#10;            updatedFormState = updatedFormState.copy(&#10;                amountError = context.getString(R.string.error_amount_greater_zero)&#10;            )&#10;            isValid = false&#10;        }&#10;&#10;        if (formState.title.isBlank()) {&#10;            updatedFormState = updatedFormState.copy(&#10;                titleError = context.getString(R.string.error_title_empty)&#10;            )&#10;            isValid = false&#10;        }&#10;&#10;        if (formState.selectedCategory == null) {&#10;            updatedFormState = updatedFormState.copy(&#10;                categoryError = context.getString(R.string.error_select_category)&#10;            )&#10;            isValid = false&#10;        }&#10;&#10;        _transactionFormState.value = updatedFormState&#10;&#10;        return isValid&#10;    }&#10;&#10;    fun saveReceiptAsTransactions(receipt: Receipt) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val defaultCategory = getDefaultCategory()&#10;&#10;                receipt.items.forEach { item -&gt;&#10;                    val transaction = Transaction(&#10;                        id = 0,&#10;                        amount = item.price,&#10;                        title = item.name,&#10;                        description = context.getString(&#10;                            R.string.transactions_from_receipt,&#10;                            receipt.storeName ?: context.getString(R.string.common_unknown)&#10;                        ),&#10;                        category = defaultCategory,&#10;                        date = System.currentTimeMillis(),&#10;                        isExpense = true&#10;                    )&#10;                    transactionRepository.insertTransaction(transaction)&#10;                }&#10;&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun getDefaultCategory(): TransactionCategory {&#10;        return try {&#10;            val categories = categoryRepository.allCategories.first()&#10;            categories.firstOrNull()&#10;                ?: TransactionCategory(&#10;                    id = 1,&#10;                    name = context.getString(R.string.category_shopping),&#10;                    color = 0xFF4CAF50.toInt(),&#10;                    icon = 0&#10;                )&#10;        } catch (e: Exception) {&#10;            TransactionCategory(&#10;                id = 1,&#10;                name = context.getString(R.string.category_shopping),&#10;                color = 0xFF4CAF50.toInt(),&#10;                icon = 0&#10;            )&#10;        }&#10;    }&#10;&#10;    fun refreshFinancialSummary() {&#10;        viewModelScope.launch {&#10;            try {&#10;                loadFinancialSummary()&#10;            } catch (e: Exception) {&#10;                // Handle error&#10;            }&#10;        }&#10;    }&#10;&#10;    fun refreshTransactions() {&#10;        loadTransactions()&#10;    }&#10;&#10;    fun addTransactionDirect(transaction: Transaction) {&#10;        viewModelScope.launch {&#10;            try {&#10;                transactionRepository.insertTransaction(transaction)&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    fun resetFormState() {&#10;        _transactionFormState.value = TransactionFormState()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.pixelpioneer.moneymaster.ui.viewmodel&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.pixelpioneer.moneymaster.R&#10;import com.pixelpioneer.moneymaster.core.util.UiState&#10;import com.pixelpioneer.moneymaster.data.model.FinancialSummary&#10;import com.pixelpioneer.moneymaster.data.model.Receipt&#10;import com.pixelpioneer.moneymaster.data.model.Transaction&#10;import com.pixelpioneer.moneymaster.data.model.TransactionCategory&#10;import com.pixelpioneer.moneymaster.data.model.TransactionFormState&#10;import com.pixelpioneer.moneymaster.data.repository.CategoryRepository&#10;import com.pixelpioneer.moneymaster.data.repository.TransactionRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.catch&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for managing transactions and related financial data.&#10; *&#10; * Handles loading, creating, updating, and deleting transactions,&#10; * as well as managing categories, form state, and financial summaries.&#10; * Provides UI state flows for transactions and summaries.&#10; *&#10; * @property transactionRepository Repository for transaction data access.&#10; * @property categoryRepository Repository for category data access.&#10; * @property context Application context for accessing resources.&#10; */&#10;@HiltViewModel&#10;class TransactionViewModel @Inject constructor(&#10;    private val transactionRepository: TransactionRepository,&#10;    private val categoryRepository: CategoryRepository,&#10;    @ApplicationContext private val context: Context&#10;) : ViewModel() {&#10;    /**&#10;     * UI state for transaction list data.&#10;     */&#10;    private val _transactionsState = MutableStateFlow&lt;UiState&lt;List&lt;Transaction&gt;&gt;&gt;(UiState.Loading)&#10;    &#10;    /**&#10;     * Public UI state flow for transaction list data.&#10;     */&#10;    val transactionsState: StateFlow&lt;UiState&lt;List&lt;Transaction&gt;&gt;&gt; = _transactionsState&#10;&#10;    /**&#10;     * UI state for category list data.&#10;     */&#10;    private val _categoriesState =&#10;        MutableStateFlow&lt;UiState&lt;List&lt;TransactionCategory&gt;&gt;&gt;(UiState.Loading)&#10;    &#10;    /**&#10;     * Public UI state flow for category list data.&#10;     */&#10;    val categoriesState: StateFlow&lt;UiState&lt;List&lt;TransactionCategory&gt;&gt;&gt; = _categoriesState&#10;&#10;    /**&#10;     * UI state for the currently selected transaction.&#10;     */&#10;    private val _selectedTransaction = MutableStateFlow&lt;UiState&lt;Transaction&gt;&gt;(UiState.Loading)&#10;    &#10;    /**&#10;     * Public UI state flow for the currently selected transaction.&#10;     */&#10;    val selectedTransaction: StateFlow&lt;UiState&lt;Transaction&gt;&gt; = _selectedTransaction&#10;&#10;    /**&#10;     * Current state of the transaction form.&#10;     */&#10;    private val _transactionFormState = MutableStateFlow(TransactionFormState())&#10;    &#10;    /**&#10;     * Public state flow for the transaction form.&#10;     */&#10;    val transactionFormState: StateFlow&lt;TransactionFormState&gt; = _transactionFormState&#10;&#10;    /**&#10;     * UI state for financial summary data.&#10;     */&#10;    private val _financialSummary = MutableStateFlow&lt;UiState&lt;FinancialSummary&gt;&gt;(UiState.Loading)&#10;    &#10;    /**&#10;     * Public UI state flow for financial summary data.&#10;     */&#10;    val financialSummary: StateFlow&lt;UiState&lt;FinancialSummary&gt;&gt; = _financialSummary&#10;&#10;    init {&#10;        loadTransactions()&#10;        loadCategories()&#10;        loadFinancialSummary()&#10;    }&#10;&#10;    /**&#10;     * Loads all transactions with their associated categories.&#10;     */&#10;    private fun loadTransactions() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _transactionsState.value = UiState.Loading&#10;                transactionRepository.allTransactionsWithCategory&#10;                    .catch { e -&gt;&#10;                        _transactionsState.value =&#10;                            UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;                    }&#10;                    .collect { transactions -&gt;&#10;                        if (transactions.isEmpty()) {&#10;                            _transactionsState.value = UiState.Empty&#10;                        } else {&#10;                            _transactionsState.value = UiState.Success(transactions)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _transactionsState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Loads a specific transaction by its ID.&#10;     *&#10;     * @param id ID of the transaction to load&#10;     */&#10;    fun loadTransactionById(id: Long) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _selectedTransaction.value = UiState.Loading&#10;                transactionRepository.getTransactionById(id)&#10;                    .catch { e -&gt;&#10;                        _selectedTransaction.value =&#10;                            UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;                    }&#10;                    .collect { transaction -&gt;&#10;                        _selectedTransaction.value = UiState.Success(transaction)&#10;                    }&#10;            } catch (e: Exception) {&#10;                _selectedTransaction.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Loads all available transaction categories.&#10;     */&#10;    private fun loadCategories() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _categoriesState.value = UiState.Loading&#10;                categoryRepository.allCategories&#10;                    .catch { e -&gt;&#10;                        _categoriesState.value =&#10;                            UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;                    }&#10;                    .collect { categories -&gt;&#10;                        if (categories.isEmpty()) {&#10;                            _categoriesState.value = UiState.Empty&#10;                        } else {&#10;                            _categoriesState.value = UiState.Success(categories)&#10;                        }&#10;                    }&#10;            } catch (e: Exception) {&#10;                _categoriesState.value =&#10;                    UiState.Error(e.message ?: context.getString(R.string.error_unknown))&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Loads financial summary data including total income, expenses, and balance.&#10;     */&#10;    private fun loadFinancialSummary() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _financialSummary.value = UiState.Loading&#10;&#10;                combine(&#10;                    transactionRepository.getTotalIncomeByMonth(),&#10;                    transactionRepository.getTotalExpensesByMonth()&#10;                ) { income, expenses -&gt;&#10;                    val balance = income - expenses&#10;                    FinancialSummary(&#10;                        totalIncome = income,&#10;                        totalExpenses = expenses,&#10;                        balance = balance&#10;                    )&#10;                }.catch { e -&gt;&#10;                    _financialSummary.value = UiState.Error(&#10;                        e.message ?: context.getString(R.string.error_unknown)&#10;                    )&#10;                }.collect { summary -&gt;&#10;                    _financialSummary.value = UiState.Success(summary)&#10;                }&#10;            } catch (e: Exception) {&#10;                _financialSummary.value = UiState.Error(&#10;                    e.message ?: context.getString(R.string.error_unknown)&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Creates a new transaction using the current form state.&#10;     *&#10;     * @param onComplete Callback to execute after transaction creation&#10;     */&#10;    fun createTransaction(onComplete: () -&gt; Unit = {}) {&#10;        viewModelScope.launch {&#10;            val formState = _transactionFormState.value&#10;&#10;            if (!validateTransactionForm()) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                val category = _transactionFormState.value.selectedCategory&#10;                    ?: throw IllegalStateException(&quot;Category cannot be null&quot;)&#10;&#10;                val transaction = Transaction(&#10;                    amount = formState.amount,&#10;                    title = formState.title,&#10;                    description = formState.description,&#10;                    category = category,&#10;                    date = formState.date,&#10;                    isExpense = formState.isExpense&#10;                )&#10;&#10;                transactionRepository.insertTransaction(transaction)&#10;                resetFormState()&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;                onComplete()&#10;            } catch (e: Exception) {&#10;                // Error handling&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    /**&#10;     * Updates an existing transaction with the current form state.&#10;     *&#10;     * @param id ID of the transaction to update&#10;     */&#10;    fun updateTransaction(id: Long) {&#10;        viewModelScope.launch {&#10;            val formState = _transactionFormState.value&#10;&#10;            if (!validateTransactionForm()) {&#10;                return@launch&#10;            }&#10;&#10;            try {&#10;                val category = _transactionFormState.value.selectedCategory&#10;                    ?: throw IllegalStateException(&quot;Category cannot be null&quot;)&#10;&#10;                val transaction = Transaction(&#10;                    id = id,&#10;                    amount = formState.amount,&#10;                    title = formState.title,&#10;                    description = formState.description,&#10;                    category = category,&#10;                    date = formState.date,&#10;                    isExpense = formState.isExpense&#10;                )&#10;&#10;                transactionRepository.updateTransaction(transaction)&#10;&#10;                resetFormState()&#10;&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;&#10;                loadTransactionById(id)&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Deletes a transaction.&#10;     *&#10;     * @param transaction The transaction to delete&#10;     */&#10;    fun deleteTransaction(transaction: Transaction) {&#10;        viewModelScope.launch {&#10;            try {&#10;                transactionRepository.deleteTransaction(transaction)&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the amount field in the transaction form.&#10;     * Sets error if amount is invalid.&#10;     *&#10;     * @param amount The new amount value&#10;     */&#10;    fun updateAmount(amount: Double) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(&#10;            amount = amount,&#10;            amountError = if (amount &lt;= 0) context.getString(R.string.error_amount_greater_zero) else null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Updates the title field in the transaction form.&#10;     * Sets error if title is invalid.&#10;     *&#10;     * @param title The new title value&#10;     */&#10;    fun updateTitle(title: String) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(&#10;            title = title,&#10;            titleError = if (title.isBlank()) context.getString(R.string.error_title_empty) else null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Updates the description field in the transaction form.&#10;     *&#10;     * @param description The new description value&#10;     */&#10;    fun updateDescription(description: String) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(description = description)&#10;    }&#10;&#10;    /**&#10;     * Updates the selected category in the transaction form.&#10;     *&#10;     * @param category The new selected category&#10;     */&#10;    fun updateSelectedCategory(category: TransactionCategory) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(&#10;            selectedCategory = category,&#10;            categoryError = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Updates the date field in the transaction form.&#10;     *&#10;     * @param date The new date value in milliseconds&#10;     */&#10;    fun updateDate(date: Long) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(date = date)&#10;    }&#10;&#10;    /**&#10;     * Updates whether the transaction is an expense or income.&#10;     *&#10;     * @param isExpense True if transaction is an expense, false if income&#10;     */&#10;    fun updateIsExpense(isExpense: Boolean) {&#10;        _transactionFormState.value = _transactionFormState.value.copy(isExpense = isExpense)&#10;    }&#10;&#10;    /**&#10;     * Initializes the form with data from an existing transaction.&#10;     *&#10;     * @param transaction The transaction to load into the form&#10;     */&#10;    fun initFormWithTransaction(transaction: Transaction) {&#10;        _transactionFormState.value = TransactionFormState(&#10;            amount = transaction.amount,&#10;            title = transaction.title,&#10;            description = transaction.description,&#10;            selectedCategory = transaction.category,&#10;            date = transaction.date,&#10;            isExpense = transaction.isExpense&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Validates the transaction form fields.&#10;     * Updates error messages if validation fails.&#10;     *&#10;     * @return True if form is valid, false otherwise&#10;     */&#10;    private fun validateTransactionForm(): Boolean {&#10;        val formState = _transactionFormState.value&#10;        var isValid = true&#10;&#10;        var updatedFormState = formState&#10;&#10;        if (formState.amount &lt;= 0) {&#10;            updatedFormState = updatedFormState.copy(&#10;                amountError = context.getString(R.string.error_amount_greater_zero)&#10;            )&#10;            isValid = false&#10;        }&#10;&#10;        if (formState.title.isBlank()) {&#10;            updatedFormState = updatedFormState.copy(&#10;                titleError = context.getString(R.string.error_title_empty)&#10;            )&#10;            isValid = false&#10;        }&#10;&#10;        if (formState.selectedCategory == null) {&#10;            updatedFormState = updatedFormState.copy(&#10;                categoryError = context.getString(R.string.error_select_category)&#10;            )&#10;            isValid = false&#10;        }&#10;&#10;        _transactionFormState.value = updatedFormState&#10;&#10;        return isValid&#10;    }&#10;&#10;    /**&#10;     * Converts a receipt into multiple transactions and saves them.&#10;     *&#10;     * @param receipt The receipt containing items to convert to transactions&#10;     */&#10;    fun saveReceiptAsTransactions(receipt: Receipt) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val defaultCategory = getDefaultCategory()&#10;&#10;                receipt.items.forEach { item -&gt;&#10;                    val transaction = Transaction(&#10;                        id = 0,&#10;                        amount = item.price,&#10;                        title = item.name,&#10;                        description = context.getString(&#10;                            R.string.transactions_from_receipt,&#10;                            receipt.storeName ?: context.getString(R.string.common_unknown)&#10;                        ),&#10;                        category = defaultCategory,&#10;                        date = System.currentTimeMillis(),&#10;                        isExpense = true&#10;                    )&#10;                    transactionRepository.insertTransaction(transaction)&#10;                }&#10;&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the default transaction category, creating one if necessary.&#10;     *&#10;     * @return A default TransactionCategory&#10;     */&#10;    private suspend fun getDefaultCategory(): TransactionCategory {&#10;        return try {&#10;            val categories = categoryRepository.allCategories.first()&#10;            categories.firstOrNull()&#10;                ?: TransactionCategory(&#10;                    id = 1,&#10;                    name = context.getString(R.string.category_shopping),&#10;                    color = 0xFF4CAF50.toInt(),&#10;                    icon = 0&#10;                )&#10;        } catch (e: Exception) {&#10;            TransactionCategory(&#10;                id = 1,&#10;                name = context.getString(R.string.category_shopping),&#10;                color = 0xFF4CAF50.toInt(),&#10;                icon = 0&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refreshes the financial summary data.&#10;     */&#10;    fun refreshFinancialSummary() {&#10;        viewModelScope.launch {&#10;            try {&#10;                loadFinancialSummary()&#10;            } catch (e: Exception) {&#10;                // Handle error&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Refreshes the transactions list.&#10;     */&#10;    fun refreshTransactions() {&#10;        loadTransactions()&#10;    }&#10;&#10;    /**&#10;     * Directly adds a fully formed transaction.&#10;     *&#10;     * @param transaction The transaction to add&#10;     */&#10;    fun addTransactionDirect(transaction: Transaction) {&#10;        viewModelScope.launch {&#10;            try {&#10;                transactionRepository.insertTransaction(transaction)&#10;                loadTransactions()&#10;                loadFinancialSummary()&#10;            } catch (e: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resets the transaction form to its default state.&#10;     */&#10;    fun resetFormState() {&#10;        _transactionFormState.value = TransactionFormState()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>